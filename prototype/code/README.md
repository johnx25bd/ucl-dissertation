# A dapp for smart containers

## Smart contract

Each container (device? scalability issues here) will have an instance of a contract deployed on the EVM. This contract will contain the code necessary to manage physical and informational access.

### Physical access

Agents and the conditions under which they can access container contents are defined and managed in this contract.

Agents requiring access to shipping containers at various points in the transit chain include those loading the container, custodians in the supply chain (possibly - though possibly not), employees processing container contents once the container reaches the destination distribution facility, customs inspection officials, ship crew if conditions require (i.e. refrigerator failure or moisture detected).

(An aside - interestingly, if functional, this system means that a warrant would provide access to authorized agents, and that such agents would be unable to access container contents without such an attestation signed by the issuing authority, presumably a court or judge.)

### Informational access

Similarly, container contract instances must define the conditions and entities (agents) entitled to access the informational assets stored on board the container. To ensure privacy of information in transit, a proxy re-encryption service (such as NuCypher's Umbral Proxy Re-Encryption library) will likely be employed. With this scheme, a ciphertext encrypted by the edge processor will be transmitted to a network of proxies, which will re-encrypt the data, to be decrypted by the target recipients' private keys. This solves the problem of the computational (and therefore energy) intensity of re-encrypting sensitive data, and enables the secure distribution of IoT data to authorized actors.  

How are users authorized to access data? This question deserves much consideration, as it carries deep ethical and technical implications. Thorough analysis may be beyond the scope of this research effort, though we will examine aspects. Our initial intuition is that the owners of the devices capturing the data, as well as the the subjects (or owners of the subjects?) of the data both have a right to the data, and to the value created by it. And, thinking more critically, the owner of the sensor should probably have less of a right to it than the subject ... this is contrary to existing US policies, by which the owner of a photograph is the person who pressed the shutter button ([Technology Law Source 2015](https://www.technologylawsource.com/2015/04/articles/intellectual-property-1/who-owns-the-photo/)). Interestingly, a few cases have indicated that the copyright of data captured or generated by computer programs (i.e. [an algorithm that takes a photo](https://www.lexology.com/library/detail.aspx?g=6f7dd0d4-f44d-4d38-a0d4-04712e978956)) does not belong to the owner of the camera, or even to the developer of the algorithm.






## User Flow

### For accessing agent:

A person (agent) wanting to gain access to a container will need to prove:

- physical proximity to the container and
- identity. (Currently, ownership of wallet address. Future, biometric mechanism.)

```
// ON ACCESSING AGENT'S DEVICE (i.e. phone)

// User scans container QR code, which invokes requestAccess:

const agentAddress = 0x...; // agent's wallet address
agentPosition = [1.0, 1.0]; // current position [lon, lat]


function requestAccess (containerId) {
  // Maybe - read to see if you have access - skip costly process if not? Would invoke a view function including containerId (wallet address?) and agent's address,  plus perhaps location, time, etc?

  alert() // Access is unlikely. Try anyway?

  // Establish connection with container.
  requestParams = {
    address: agentAddress,
    position: agentPosition
  };

  // Transmit requestParams to container.
}
```

```
// ON CONTAINER

// Has connection with Container contract instance established

function handleAccessRequest(_requestParams) {
  // listening for access request
    // Where? How can iot connect to each other, without server?

  // generate a transaction to invoke

}
```

Once these are proven (provided to the container via some local connection?), the container will generate and sign a transaction invoking a contract function with the accessing agent's wallet address, as well as container location (privacy issue here? Maybe this computation occurs on the container so locations of containers aren't revealed? Of course with a private implementation this is probably not as much of an issue.)

The function call will return a boolean `accessApproved` value, which will be passed into code on the container, unlocking it or alerting the user.



## Users

### Container authority

A smart container will require some entity (perhaps a democratic or other structure consisting of subsidiary entities) that is entitled to define access permissions to the container. Interestingly, the entity does not have to grant itself access permission, and could configure rules that prevent it granting itself access at any point.

This authority needs to, somehow, provide the information required to define smart container access conditions to a smart contract function invocation (`authorizeAccess(address[?], params)` (params can define location, time, etc), maybe). This could originate from a single externally-owned account (EOA, or wallet address), via some multisignature or threshold signature mechanism, or it could originate from a contract address occupied by a DAO.

Somehow when a container  is initially registered  in the system, some ownership or authorization initiation process needs to occur. This is likely the point of  most security vulnerability, as mis-registering the container could give control to an unintended, possibly malicious actor indefinitely.

How could the container owner / authority prove their right to own the container? How could they do this even though they are not in physical proximity to the container? This may require some coordination with the trusted hardware manufacturers ...

This authority would have the right to

- grant and revoke access rights, including definition of access conditions
- transfer authority to another entity (? - depending on implementation)


### Container

Each smart container will require a unique, securely managed private key with which it can a: sign transactions (authenticate identity) and b: decrypt transmissions meant for it.

Using Intel's EPID 2.0 scheme, we can remotely authenticate a trusted device while maintaining privacy of the device. (Is this a requirement? If so, perhaps some zero knowledge proofs or Aztec privacy-preserving protocol if using a public blockchain like Ethereum, or even if using a permissioned blockchain like Hyperledger.)

Containers will need to be registered in a smart contract, and possibly have some mapping to a data structure that will contain ownership / accessibility information.

###
